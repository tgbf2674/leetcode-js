# 二叉树的序列化与反序列化

## 解题思路

### bfs || dfs

dfs: 

序列化： 
1. 递归遍历树，关注当前节点，他的子树遍历交给递归完成
2. 前序遍历更好确定根节点
3. 遇到null阶段，翻译成特殊标记'X'，反序列化才知道这里是null

反序列化：
1. 使用dfs定义函数buildTree用于还原二叉树，将传入的序列化字符串转为list数组
2. 逐个pop出list的值，构建当前子树的根节点，构建顺序是根-左-右，如果弹出字符是'x'的，返回null节点，如果不是，则创建root节点，并递归出左右子树，最后返回root


bfs:

序列化：
1. 维护一个队列，初始让根节点入列，考察出列节点：如果出列的节点时null，将符号'X'推入res数组，如果是数值，将节点值推入数组res,并将它的左右子节点入列
2. 入列出列，直到队列为空，res构建完毕，将他用','分割为字符串

反序列化：
1. 先转成list数组，用一个指针cursor从第二项开始扫描
2. 用list[0]构建根节点，并让根节点入列
3. 节点出列，此时cursor指向他的左子节点值，cursor+1指向他的右节点值，如果子节点的值时数值，创建节点，并认出列的父亲，同时自己也是父亲入列，如果子节点时'X'，则什么都不用做
4. 所有的真实节点都会在队列里走一遍，出列就带出儿子入列
